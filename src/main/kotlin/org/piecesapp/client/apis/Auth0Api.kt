/**
* Pieces Isomorphic OpenAPI
* Endpoints for Assets, Formats, Users, Asset, Format, User.
*
* The version of the OpenAPI document: 1.0
* Contact: tsavo@pieces.app
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package org.piecesapp.client.apis

import org.openapitools.client.models.Auth0User
import org.openapitools.client.models.EmbeddedModelSchema
import org.openapitools.client.models.OAuthToken
import org.openapitools.client.models.ResultedPKCE

import org.piecesapp.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class Auth0Api(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("org.openapitools.client.baseUrl", "http://localhost:3000")
        }
    }

    /**
    * https://auth.pieces.services/v2/logout [GET]
    * https://auth0.com/docs/api/authentication#logout
    * @param clientId The client ID of the Auth0 Instance (optional)
    * @param returnTo The URL that the logout endpoint will return to (optional)
    * @return kotlin.String
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun auth0Logout(clientId: kotlin.String?, returnTo: kotlin.String?) : kotlin.String {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (clientId != null) {
                    put("client_id", listOf(clientId.toString()))
                }
                if (returnTo != null) {
                    put("returnTo", listOf(returnTo.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/v2/logout",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<kotlin.String>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * https://auth.pieces.services/authorize [GET]
    * An endpoint that is used locally authenticate via a PKCE Flow.  Example https://auth.pieces.services /authorize?audience&#x3D;https%3A%2F%2Fpieces.us.auth0.com%2Fapi%2Fv2%2F&amp;scope&#x3D;email+profile+offline_access+openid&amp;response_type&#x3D;code&amp;client_id&#x3D;9sW4Pa1LEjX67l6VO14u0207NLYeXnu1&amp;redirect_uri&#x3D;http%3A%2F%2Flocalhost%3A3000%2Fpkce%2Fresponse%2Fcode&amp;code_challenge_method&#x3D;S256&amp;code_challenge&#x3D;yxRssZxdfBpMigRmDxAety1QU72Bd5WnDUbtlsCZOnk&amp;response_mode&#x3D;form_post&amp;state&#x3D;4bd0b9a389b4b229602346c33913b4c3c199628a90011ab3a901302ab62b3832
    * @param audience  The unique identifier of the target API you want to access. 
    * @param scope The scopes which you want to request authorization for. These must be separated by a space. You can request any of the standard OpenID Connect (OIDC) scopes about users, such as profile and email, custom claims that must conform to a namespaced format, or any scopes supported by the target API (for example, read:contacts). Include offline_access to get a Refresh Token. 
    * @param responseType Indicates to Auth0 which OAuth 2.0 Flow you want to perform. Use code for Authorization Code Grant (PKCE) Flow. 
    * @param clientId Your application&#39;s Client ID. 
    * @param codeChallengeMethod Method used to generate the challenge. The PKCE spec defines two methods, S256 and plain, however, Auth0 supports only S256 since the latter is discouraged. 
    * @param codeChallenge Generated challenge from the code_verifier. 
    * @param responseMode  
    * @param state An opaque value the clients adds to the initial request that Auth0 includes when redirecting the back to the client. This value must be used by the client to prevent CSRF attacks. (optional)
    * @param redirectUri The URL to which Auth0 will redirect the browser after authorization has been granted by the user. (optional)
    * @param connection The name of the connection configured to your application. (optional)
    * @param prompt To initiate a silent authentication request, use prompt&#x3D;none (see Remarks for more info). (optional)
    * @return ResultedPKCE
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authorizeAuth0(audience: kotlin.String, scope: kotlin.collections.List<kotlin.String>, responseType: kotlin.String, clientId: kotlin.String, codeChallengeMethod: kotlin.String, codeChallenge: kotlin.String, responseMode: kotlin.String, state: kotlin.String?, redirectUri: kotlin.String?, connection: kotlin.String?, prompt: kotlin.String?) : ResultedPKCE {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("audience", listOf(audience.toString()))
                put("scope", toMultiValue(scope.toList(), "ssv"))
                put("response_type", listOf(responseType.toString()))
                put("client_id", listOf(clientId.toString()))
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (redirectUri != null) {
                    put("redirect_uri", listOf(redirectUri.toString()))
                }
                put("code_challenge_method", listOf(codeChallengeMethod.toString()))
                put("code_challenge", listOf(codeChallenge.toString()))
                if (connection != null) {
                    put("connection", listOf(connection.toString()))
                }
                if (prompt != null) {
                    put("prompt", listOf(prompt.toString()))
                }
                put("response_mode", listOf(responseMode.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/authorize",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<ResultedPKCE>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ResultedPKCE
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * https://auth.pieces.services/oauth/token [POST]
    * An endpoint to generate a OAuth Token for an authentication flow. 
    * @param grantType Denotes the flow you are using. For Authorization Code, use authorization_code or refresh_token. 
    * @param clientId Your application&#39;s Client ID. 
    * @param code The Authorization Code received from the initial /authorize call. 
    * @param redirectUri This is required only if it was set at the GET /authorize endpoint. The values must match. 
    * @param codeVerifier Cryptographically random key that was used to generate the code_challenge passed to /authorize. 
    * @param schema  (optional)
    * @param audience The audience domain: i.e. https://pieces.us.auth0.com (optional)
    * @return OAuthToken
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun exchangeForAuth0Token(grantType: kotlin.String, clientId: kotlin.String, code: kotlin.String, redirectUri: kotlin.String, codeVerifier: kotlin.String, schema: EmbeddedModelSchema?, audience: kotlin.String?) : OAuthToken {
        val localVariableBody: kotlin.Any? = mapOf("schema" to schema, "grant_type" to grantType, "client_id" to clientId, "code" to code, "redirect_uri" to redirectUri, "code_verifier" to codeVerifier, "audience" to audience)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/x-www-form-urlencoded")
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/oauth/token",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<OAuthToken>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OAuthToken
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * https://auth.pieces.services/userinfo [GET]
    * Get the users info from the Auth0 API
    * @return Auth0User
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAuth0UserInfo() : Auth0User {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/userinfo",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<Auth0User>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Auth0User
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

}
