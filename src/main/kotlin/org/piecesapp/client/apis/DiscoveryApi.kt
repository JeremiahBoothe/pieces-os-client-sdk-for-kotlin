/**
* Pieces Isomorphic OpenAPI
* Endpoints for Assets, Formats, Users, Asset, Format, User.
*
* The version of the OpenAPI document: 1.0
* Contact: tsavo@pieces.app
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package org.piecesapp.client.apis

import org.piecesapp.client.models.DiscoveredAssets
import org.piecesapp.client.models.DiscoveredHtmlWebpages
import org.piecesapp.client.models.DiscoveredRelatedTags
import org.piecesapp.client.models.DiscoveredSensitives
import org.piecesapp.client.models.SeededDiscoverableAssets
import org.piecesapp.client.models.SeededDiscoverableHtmlWebpages
import org.piecesapp.client.models.SeededDiscoverableRelatedTags
import org.piecesapp.client.models.SeededDiscoverableSensitives

import org.piecesapp.client.infrastructure.ApiClient
import org.piecesapp.client.infrastructure.ClientException
import org.piecesapp.client.infrastructure.ClientError
import org.piecesapp.client.infrastructure.ServerException
import org.piecesapp.client.infrastructure.ServerError
import org.piecesapp.client.infrastructure.MultiValueMap
import org.piecesapp.client.infrastructure.RequestConfig
import org.piecesapp.client.infrastructure.RequestMethod
import org.piecesapp.client.infrastructure.ResponseType
import org.piecesapp.client.infrastructure.Success

class DiscoveryApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("org.piecesapp.client.baseUrl", "http://localhost:3000")
        }
    }

    /**
    * /discovery/discover/assets [POST]
    * This is the endpoint used for bulk import. In both cases of the bulk import flow, fragments or files. When we already have \&quot;snippets\&quot; or fragments to discover and now our job is to check if they are actually valid snippets(clustering). Otherwise, we should have a file to parse &amp;&amp; snippitize and then run through the clustering.
    * @param automatic For most cases set to true. If this is set to true we will handle the behavior automically or else we will not proactively handle specific behavior but we will let the developer decide the behavior. (optional, default to true)
    * @param seededDiscoverableAssets The discovery/discover/assets endpoint will accept seededDiscoverableAssets, that represetns an iterable of multiple fragments or files. (optional)
    * @return DiscoveredAssets
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun discoveryDiscoverAssets(automatic: kotlin.Boolean?, seededDiscoverableAssets: SeededDiscoverableAssets?) : DiscoveredAssets {
        val localVariableBody: kotlin.Any? = seededDiscoverableAssets
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (automatic != null) {
                    put("automatic", listOf(automatic.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/discovery/discover/assets",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<DiscoveredAssets>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DiscoveredAssets
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * /discovery/discover/assets/html[POST]
    * This is the discover discover assets html endpoint. The goal of this endpoint is to either take an iterable of urls and pages(an html string) and extract all the assets from the iterable.
    * @param automatic For most cases set to true. If this is set to true we will handle the behavior automically or else we will not proactively handle specific behavior but we will let the developer decide the behavior. (optional, default to true)
    * @param seededDiscoverableHtmlWebpages  (optional)
    * @return DiscoveredHtmlWebpages
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun discoveryDiscoverAssetsHtml(automatic: kotlin.Boolean?, seededDiscoverableHtmlWebpages: SeededDiscoverableHtmlWebpages?) : DiscoveredHtmlWebpages {
        val localVariableBody: kotlin.Any? = seededDiscoverableHtmlWebpages
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (automatic != null) {
                    put("automatic", listOf(automatic.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/discovery/discover/assets/html",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<DiscoveredHtmlWebpages>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DiscoveredHtmlWebpages
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * /discovery/discover/sensitives [POST]
    * This endpoint will accept an array of text values, and attampt to extract sensitive data out of it.
    * @param automatic For most cases set to true. If this is set to true we will handle the behavior automically or else we will not proactively handle specific behavior but we will let the developer decide the behavior. (optional, default to true)
    * @param seededDiscoverableSensitives  (optional)
    * @return DiscoveredSensitives
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun discoveryDiscoverSensitives(automatic: kotlin.Boolean?, seededDiscoverableSensitives: SeededDiscoverableSensitives?) : DiscoveredSensitives {
        val localVariableBody: kotlin.Any? = seededDiscoverableSensitives
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (automatic != null) {
                    put("automatic", listOf(automatic.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/discovery/discover/sensitives",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<DiscoveredSensitives>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DiscoveredSensitives
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * /discovery/discover/tags/related [POST]
    * This will take in a tag or multiple tags and return all the tags that are related to the tag or tag provide in the body.
    * @param automatic For most cases set to true. If this is set to true we will handle the behavior automically or else we will not proactively handle specific behavior but we will let the developer decide the behavior. (optional, default to true)
    * @param seededDiscoverableRelatedTags  (optional)
    * @return DiscoveredRelatedTags
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun discoveryDiscoverTagsRelated(automatic: kotlin.Boolean?, seededDiscoverableRelatedTags: SeededDiscoverableRelatedTags?) : DiscoveredRelatedTags {
        val localVariableBody: kotlin.Any? = seededDiscoverableRelatedTags
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (automatic != null) {
                    put("automatic", listOf(automatic.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/discovery/discover/tags/related",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<DiscoveredRelatedTags>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DiscoveredRelatedTags
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

}
